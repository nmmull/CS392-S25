<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-03-12 Wed 17:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Course Notes</title>
<meta name="author" content="Nathan  Mull" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="myStyle.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '2em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '2em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up"><a href="index.html">↩</a></div><div id="content" class="content">
<h1 class="title">Course Notes</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#intro">1. What is this course?</a></li>
<li><a href="#set-up">2. Set Up</a>
<ul>
<li><a href="#org6c5199b">2.1. Cargo</a></li>
</ul>
</li>
<li><a href="#basics">3. The Basics</a>
<ul>
<li><a href="#orgd55f544">3.1. Variables and Mutability</a></li>
<li><a href="#org49fa842">3.2. Constants</a></li>
<li><a href="#orgee1d3a3">3.3. Data Types</a></li>
<li><a href="#org1bfc059">3.4. Functions</a></li>
<li><a href="#orgf003f59">3.5. Statements and Expressions</a></li>
<li><a href="#org1249811">3.6. Control Flow</a></li>
</ul>
</li>
<li><a href="#org0a94ba6">4. Ownership</a>
<ul>
<li><a href="#stack_and_heap">4.1. Stack and Heap</a></li>
<li><a href="#orgc5f42dc">4.2. References and Borrowing</a></li>
<li><a href="#orgc9f2fb4">4.3. Slice Types</a></li>
</ul>
</li>
<li><a href="#org695b3eb">5. Structures</a>
<ul>
<li><a href="#orgaf9bb52">5.1. Structures and Ownership</a></li>
<li><a href="#org18fa05d">5.2. Derived Traits</a></li>
<li><a href="#org938c99b">5.3. Methods</a></li>
<li><a href="#orgb1869a4">5.4. Associated Functions</a></li>
</ul>
</li>
<li><a href="#org9187b38">6. Proof Theory Primer</a>
<ul>
<li><a href="#orgac6f538">6.1. Propositional Logic</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This is very rough draft set of notes (more of a collection of
thoughts) for the course CAS CS 392 at Boston University.  It's
primarily a supplement to <a href="https://doc.rust-lang.org/stable/book/title-page.html">The Rust Programming Language (RPL)</a>.  It's
full of typos and dumb jokes.
</p>
<div id="outline-container-intro" class="outline-2">
<h2 id="intro"><span class="section-number-2">1.</span> What is this course?</h2>
<div class="outline-text-2" id="text-intro">
<p>
We usually learn PLs the "wrong" way: throw spaghetti code at the wall
and see what sticks.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>  This course is an experiment in
learning a PL the "right" way: give an airtight specification of a PL
using the mathematical framework of PL theory.
</p>

<p>
Rust is an excellent testbed for this kind of experiment. It's a PL
that's gaining in popularity but has some bizzaro features in its type
systems<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> that turn out to be incredibly useful for
addressing some of the more egregious bugs in low-level programming.
Add to that the fact the theoretical underpinnings of Rust are
simultaneously very old (it's based on <i>linear logic</i>, an innovation
of Jean-Yves Girard from the 80s, based on ideas that came long before
it) and very young (the formalization of Rust-proper postdates its own
conception and popularity, as evidenced by the publication year (2021)
of the paper we'll use in the second half of the course). This gives
us a wide range of sources to better understand what the heck is going
on with this language.
</p>

<p>
The points is not to learn Rust, at least not entirely.<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>  The point is to <i>understand the core of Rust</i>.
Per the previous paragraph, this means learning a bit of mathematics.
It also means dipping into research from <i>this decade</i>, which means
learning to read academic papers (more of a skill than you might
expect).  And since we're learning a PL, we might as well build
something with it.  The proverbial "they" say that you don't know a PL
until you've done a project in it.  The less-proverbial "they" might
say you don't know a PL until you understand it's formal
specification.  We'll kill two birds with one stone<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>
and build an interpreter in Rust for a subset of Rust.  So our rough
plan:
</p>

<ul class="org-ul">
<li>learn enough Rust to be dangerous</li>
<li>learn to read/practice reading research papers in PL, so that we can
read a paper which gives a formal specification of a subset of Rust
(we'll do this together as a group)</li>
<li>Test our knowledge by <i>implementing</i> that subset of Rust <i>in Rust</i></li>
</ul>

<p>
Now, admittedly, I'd like to believe that's all the motivation we'll
need.  If you're interested in this course, I'd hope you also have some
iota of preexisting interest in Rust.  But it is my duty to
(begrudgingly) motivate why you should learn something interesting.
</p>
<ul class="org-ul">
<li><b>For those interested in PL:</b> Linear types, affine types, types for
concurrency, these are <i>current</i> research areas.  Rust is something
of a success story, one of those rare instances of a PL becoming
popular for being both interesting and usable.  If you took CS320,
it's one thing to give a formal specification of a clean functional
PL, applying these ideas to Rust and friends will be a formative
challenge.</li>
<li><b>For those interested in programming:</b> I am of the opinion that it's
always valuable to learn a new language paradigm, but maybe that's
not enough motivation──Rust is ranked 14th according to the
<a href="https://www.tiobe.com/tiobe-index/">December 2024 TIOBE index</a>
with one of the most <a href="https://www.tiobe.com/tiobe-index/rust/">generally uptrending graphs</a> in the top 20.
It's being adopted by large companies like Amazon and Microsoft, but
also smaller companies, anyone who needs safe low-level code.  Rust
is an <i>ahead-of-time compiled</i> language; it's good to have one of
those in your back pocket, and I think Rust is one of the more
interesting choices (over, say, C).</li>
<li><b>For those interested in systems:</b> I can't pretend to really know
what's going on in the world of systems, but Rust touts itself as
having a lot of potential in this area.  It may be worthwhile to
understand it, even if just to be able to adequately respond to the
hype.</li>
<li><b>Everyone else:</b> I dunno, good luck. If you're not one of the above,
I honestly don't see any reason why you should learn Rust.</li>
</ul>

<p>
Enough preamble, let's Rust.
</p>
</div>
</div>
<div id="outline-container-set-up" class="outline-2">
<h2 id="set-up"><span class="section-number-2">2.</span> Set Up</h2>
<div class="outline-text-2" id="text-set-up">
<p>
Set up and installation of Rust is comparatively easy.  We'll
primarily be using <b>Cargo</b>, a build system for Rust akin to OCaml's Dune
(but quite a bit better).  You should follow the <code>rustup</code> <a href="https://doc.rust-lang.org/stable/book/ch01-01-installation.html">installation
instructions</a> in RPL for your OS.
</p>

<blockquote>
<p>
<b>Note:</b> If you're running Windows, then I'll assume that you're
using WSL.  You're welcome to try to install directly, but <i>I will not
help you troubleshoot.</i> Not so much because I don't want (also, I
don't) but because I don't really know how.
</p>
</blockquote>

<p>
If you'd like, you can go through the <a href="https://doc.rust-lang.org/stable/book/ch01-02-hello-world.html">Hello, World!</a> section of RPL,
but we won't be using the rust compiler directly in this course.
Instead, we'll follow RPL's recommendations on project hygiene and
always assume a Cargo project.  You <i>should</i> go through the <a href="https://doc.rust-lang.org/stable/book/ch01-03-hello-cargo.html">Hello,
Cargo!</a> section of RPL (we'll also go over it in lecture).
</p>
</div>

<div id="outline-container-org6c5199b" class="outline-3">
<h3 id="org6c5199b"><span class="section-number-3">2.1.</span> Cargo</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Cargo is a build system for Rust.  As usual, you can use
</p>

<div class="org-src-container">
<pre class="src src-bash">cargo --help
</pre>
</div>

<p>
To see a list of commands for Cargo.  The main one's we'll need:
</p>
<ul class="org-ul">
<li><code>cargo new project_name</code>: create a new Cargo project (and directory)
called <code>cargo_name</code></li>
<li><code>cargo build:</code> Compile the project</li>
<li><code>cargo run:</code> Run the executable built by <code>cargo build</code> (rebuilds
first if necessary)</li>
<li><code>cargo clean:</code> Cleans up build files (usually not necessary, but a
good first step when troubleshooting an error)</li>
</ul>

<p>
You should go through the <a href="https://doc.rust-lang.org/stable/book/ch01-03-hello-cargo.html">Hello, Cargo!</a> section of RPL to practice
this process.
</p>
</div>
</div>
</div>
<div id="outline-container-basics" class="outline-2">
<h2 id="basics"><span class="section-number-2">3.</span> The Basics</h2>
<div class="outline-text-2" id="text-basics">
<p>
This is a collection of concepts that are common to all PLs.  I expect
that you're already familiar with all of these concepts.  The goal
here is to provide a more careful analysis of these concepts,
primarily with respect to syntax.  Each section begins with a BNF
specification of the Rust syntax.  These specifications are
approximations, but for simple programs are sufficient.
</p>
</div>
<div id="outline-container-orgd55f544" class="outline-3">
<h3 id="orgd55f544"><span class="section-number-3">3.1.</span> Variables and Mutability</h3>
<div class="outline-text-3" id="text-3-1">
<blockquote>
<p>
<b>Grammar:</b>
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">var-decl</span>&gt;  <span style="color: #008b8b;">::=</span> let &lt;<span style="color: #483d8b;">var-ident</span>&gt; = &lt;<span style="color: #483d8b;">expr</span>&gt;
              <span style="color: #ff0000; font-weight: bold;">|</span> let mut &lt;<span style="color: #483d8b;">var-ident</span>&gt; = &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">assign</span>&gt;    <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-ident</span>&gt; = &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">var-ident</span>&gt; <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; snake_case ;</span>
</pre>
</div>
</blockquote>

<p>
Variables are immutable by default.  This is generally safer
(mutability is the root of much evil).  If you attempt to mutate an
immutable variable, you'll get a compiler error.  You can reuse (i.e.,
shadow) variable names with declarations.
</p>

<blockquote>
<p>
<b>Example:</b>
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">let</span> <span style="color: #a0522d;">x</span> = 1;         <span style="color: #b22222;">// </span><span style="color: #b22222;">assign x to the value 1</span>
<span style="color: #483d8b;">assert_eq!</span>(x, 1);  <span style="color: #b22222;">// </span><span style="color: #b22222;">assert that x is equal to 1</span>
                   <span style="color: #b22222;">// </span><span style="color: #b22222;">(also, note the comment syntax)</span>
</pre>
</div>
</blockquote>

<p>
We use the <code>mut</code> keyword to declare mutable variables, which are
allowed to be reassigned/mutated.
</p>

<blockquote>
<p>
<b>Example:</b>
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">let</span> <span style="color: #a020f0;">mut</span> <span style="color: #a0522d;">x</span> = 1;
x = 2;
<span style="color: #483d8b;">assert_eq!</span>(x, 2);
</pre>
</div>
</blockquote>
</div>
</div>
<div id="outline-container-org49fa842" class="outline-3">
<h3 id="org49fa842"><span class="section-number-3">3.2.</span> Constants</h3>
<div class="outline-text-3" id="text-3-2">
<blockquote>
<p>
<b>Grammar:</b>
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">const-decl</span>&gt;  <span style="color: #008b8b;">::=</span> const &lt;<span style="color: #483d8b;">const-ident</span>&gt; : &lt;<span style="color: #483d8b;">ty</span>&gt; = &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">const-ident</span>&gt; <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; SCREAMING_SNAKE_CASE ;</span>
</pre>
</div>
</blockquote>

<p>
Constants are like immutable variables except that:
</p>

<ul class="org-ul">
<li>they are declared with the <code>const</code> keyword</li>
<li>by convention, they are named using <code>SCREAMING_SNAKE_CASE</code></li>
<li>they must be type annotated</li>
<li>they must be assigned to values computed at compile-time (e.g., no
stdin reads)</li>
</ul>

<p>
Constants are primarily useful for code clarity.
</p>

<blockquote>
<p>
<b>Example:</b>
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">const</span> <span style="color: #a0522d;">SPEED_OF_LIGHT</span> : <span style="color: #228b22;">u32</span> = 299792458;
<span style="color: #483d8b;">assert_eq!</span>(<span style="color: #228b22;">SPEED_OF_LIGHT</span>, 299792458);
</pre>
</div>
</blockquote>
</div>
</div>
<div id="outline-container-orgee1d3a3" class="outline-3">
<h3 id="orgee1d3a3"><span class="section-number-3">3.3.</span> Data Types</h3>
<div class="outline-text-3" id="text-3-3">
<blockquote>
<p>
<b>Grammar:</b>
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">ty</span>&gt;          <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">scalar-ty</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">compound-ty</span>&gt;
&lt;<span style="color: #0000ff;">scalar-ty</span>&gt;   <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">int-ty</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">float-ty</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> bool <span style="color: #ff0000; font-weight: bold;">|</span> char
&lt;<span style="color: #0000ff;">int-ty</span>&gt;      <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">sint-ty</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">uint-ty</span>&gt;
&lt;<span style="color: #0000ff;">sint-ty</span>&gt;     <span style="color: #008b8b;">::=</span> i16 <span style="color: #ff0000; font-weight: bold;">|</span> i32 <span style="color: #ff0000; font-weight: bold;">|</span> i64 <span style="color: #ff0000; font-weight: bold;">|</span> i128 <span style="color: #ff0000; font-weight: bold;">|</span> isize
&lt;<span style="color: #0000ff;">uint-ty</span>&gt;     <span style="color: #008b8b;">::=</span> u16 <span style="color: #ff0000; font-weight: bold;">|</span> u32 <span style="color: #ff0000; font-weight: bold;">|</span> u64 <span style="color: #ff0000; font-weight: bold;">|</span> u128 <span style="color: #ff0000; font-weight: bold;">|</span> usize
&lt;<span style="color: #0000ff;">float-ty</span>&gt;    <span style="color: #008b8b;">::=</span> f32 <span style="color: #ff0000; font-weight: bold;">|</span> f64
&lt;<span style="color: #0000ff;">compound-ty</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">tuple-ty</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">array-ty</span>&gt;
&lt;<span style="color: #0000ff;">tys</span>&gt;         <span style="color: #008b8b;">::=</span> &#1013; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">ty</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">ty</span>&gt; , &lt;<span style="color: #483d8b;">tys</span>&gt;
&lt;<span style="color: #0000ff;">tuple-ty</span>&gt;    <span style="color: #008b8b;">::=</span> ( &lt;<span style="color: #483d8b;">tys</span>&gt; )
&lt;<span style="color: #0000ff;">array-ty</span>&gt;    <span style="color: #008b8b;">::=</span> [&lt;<span style="color: #483d8b;">ty</span>&gt;&#65307;&lt;<span style="color: #483d8b;">expr</span>&gt;]

&lt;<span style="color: #0000ff;">int-lit</span>&gt;     <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; see docs ;</span>
&lt;<span style="color: #0000ff;">float-lit</span>&gt;   <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; see docs ;</span>
&lt;<span style="color: #0000ff;">char-lit</span>&gt;    <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; see docs ;</span>
&lt;<span style="color: #0000ff;">bool-lit</span>&gt;    <span style="color: #008b8b;">::=</span> true <span style="color: #ff0000; font-weight: bold;">|</span> false

&lt;<span style="color: #0000ff;">exprs</span>&gt;       <span style="color: #008b8b;">::=</span> &#1013; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt; , &lt;<span style="color: #483d8b;">exprs</span>&gt;
&lt;<span style="color: #0000ff;">tuple-lit</span>&gt;   <span style="color: #008b8b;">::=</span> ( &lt;<span style="color: #483d8b;">exprs</span>&gt; )
&lt;<span style="color: #0000ff;">tuple-field</span>&gt; <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; see docs ;</span>
&lt;<span style="color: #0000ff;">expr</span>&gt;        <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">expr</span>&gt;.&lt;<span style="color: #483d8b;">tuple-field</span>&gt;

&lt;<span style="color: #0000ff;">list-lit</span>&gt;    <span style="color: #008b8b;">::=</span> [ &lt;<span style="color: #483d8b;">exprs</span>&gt; ]
&lt;<span style="color: #0000ff;">expr</span>&gt;        <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">expr</span>&gt;[&lt;<span style="color: #483d8b;">expr</span>&gt;]

&lt;<span style="color: #0000ff;">lit</span>&gt;         <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">int-lit</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">float-lit</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">char-lit</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">bool-lit</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">tuple-lit</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">string-lit</span>&gt;
</pre>
</div>
</blockquote>

<p>
Rust is statically typed, i.e., the type of every variable is known at
compile-time.  Rust does some amount of type inference (except for
constant, it seems).  When in doubt, type annotate variables. It
doesn't hurt, and can act as a simple form of documentation.
</p>

<p>
There are two kinds of data types: <b>scalar</b> and <b>compound</b>.  Here's a
short outline, most of this should be familiar.
</p>

<ul class="org-ul">
<li>Scalar:
<ul class="org-ul">
<li>Integers:
<ul class="org-ul">
<li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, and <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li>
<li>The number indicates the number of bits used to represent the
integer. <b>The default for type inference is i32.</b></li>
<li>There is also <code>isize</code> and <code>usize</code> used for indexing</li>
<li>There are standard literals for decimal, hex, octal, binary, and
bytes.  Look them up if you need them.</li>
<li>Rust's compiler can check for integer overflow in debug mode, but
wraps by default for release mode.  We're gonna ignore this for
now (as if we'll be writing any production code&#x2026;)</li>
</ul></li>
<li>Floating-point numbers:
<ul class="org-ul">
<li><code>f32</code> and <code>f64</code>. <b>The default for type inference is <code>f64</code>.</b></li>
<li>Represented using IEEE-754 (of course)</li>
</ul></li>
<li>Characters:
<ul class="org-ul">
<li>type: <code>char</code></li>
<li>example: <code>'q'</code>, <code>'✗'</code></li>
<li>four bytes, represent unicode scalars (characters are weird but
we won't dwell on this)</li>
</ul></li>
<li>Booleans:
<ul class="org-ul">
<li>type: <code>bool</code></li>
<li>two literals: <code>true</code> and <code>false</code></li>
</ul></li>
</ul></li>
<li>Compound:
<ul class="org-ul">
<li>Tuples:
<ul class="org-ul">
<li>type: <code>(t1, t2,..., tk)</code></li>
<li>literal: <code>(e1, e2,..., ek)</code></li>
<li><p>
accessor: <code>p.i</code>
</p>
<blockquote>
<p>
<b>Example:</b>
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">let</span> <span style="color: #a0522d;">tup</span>: (<span style="color: #228b22;">i32</span>, <span style="color: #228b22;">bool</span>, <span style="color: #228b22;">u32</span>) = (2, <span style="color: #a020f0;">true</span>, 2);
<span style="color: #483d8b;">assert_eq!</span>(tup.1, <span style="color: #a020f0;">true</span>);
</pre>
</div>
</blockquote></li>
</ul></li>
<li>Arrays:
<ul class="org-ul">
<li>type: <code>[t; n]</code> where <code>t</code> is a type and <code>n</code> is a <code>usize</code> for the
number of elements. <b>IMPORTANT: Arrays are fixed length.</b></li>
<li>Arrays are allocated on the stack. Rust panics if an index is
out of bounds (in particular, it <i>actually checks</i> at runtime).</li>
<li><p>
indexing: <code>a[i]</code>, where <code>i</code> is a <code>usize</code>.
</p>
<blockquote>
<p>
<b>Example:</b>
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">const</span> <span style="color: #a0522d;">J</span> : <span style="color: #228b22;">usize</span> = 5;
<span style="color: #a020f0;">let</span> <span style="color: #a0522d;">a</span> : [<span style="color: #228b22;">u32</span>; <span style="color: #228b22;">J</span>] = [1, 2, 3, 4, 5];
<span style="color: #a020f0;">let</span> <span style="color: #a0522d;">i</span> : <span style="color: #228b22;">usize</span> = 2;
<span style="color: #483d8b;">assert_eq!</span>(a[i], 3);
</pre>
</div>
</blockquote></li>
</ul></li>
</ul></li>
</ul>

<p>
Check the appendix in RPL on <a href="https://doc.rust-lang.org/stable/book/appendix-02-operators.html#operators">Operators</a> for details on operators,
arithmetic, Boolean or otherwise.  We will, of course, see more types
as the course goes on (and define our own types).
</p>
</div>
</div>
<div id="outline-container-org1bfc059" class="outline-3">
<h3 id="org1bfc059"><span class="section-number-3">3.4.</span> Functions</h3>
<div class="outline-text-3" id="text-3-4">
<blockquote>
<p>
<b>Grammar:</b>
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">fun-decl</span>&gt;  <span style="color: #008b8b;">::=</span> fn &lt;<span style="color: #483d8b;">fun-ident</span>&gt;(&lt;<span style="color: #483d8b;">params</span>&gt;) &lt;<span style="color: #483d8b;">block</span>&gt;
              <span style="color: #ff0000; font-weight: bold;">|</span> fn &lt;<span style="color: #483d8b;">fun-ident</span>&gt;(&lt;<span style="color: #483d8b;">params</span>&gt;) -&gt; &lt;<span style="color: #483d8b;">ty</span>&gt; &lt;<span style="color: #483d8b;">block</span>&gt;
&lt;<span style="color: #0000ff;">params</span>&gt;    <span style="color: #008b8b;">::=</span> &#1013; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">param</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">param</span>&gt; , &lt;<span style="color: #483d8b;">params</span>&gt;
&lt;<span style="color: #0000ff;">param</span>&gt;     <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-ident</span>&gt; : &lt;<span style="color: #483d8b;">ty</span>&gt;
&lt;<span style="color: #0000ff;">block</span>&gt;     <span style="color: #008b8b;">::=</span> { &lt;<span style="color: #483d8b;">stmts</span>&gt; }
&lt;<span style="color: #0000ff;">fun-ident</span>&gt; <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; snake_case ;</span>
</pre>
</div>
</blockquote>

<p>
Functions in Rust behave much like functions in other PLs.  A couple
key notes:
</p>
<ul class="org-ul">
<li>parameters must be type-annotated</li>
<li>the return type must be given if the function returns a value</li>
</ul>

<p>
There is a <code>return</code> keyword, but we don't often use it; the return
value is the last expression in the function block. If no last
expression is given then the return value is <code>()</code> of type <code>()</code> (i.e.,
the unit type); see the <code>&lt;block&gt;</code> case in the given grammar for more
details about how the bodies of functions might look (there's a bit of
trickiness with regards to semicolons but I'm not going to dwell on it
since the compiler is pretty good at catching these things).
</p>

<blockquote>
<p>
<b>Example:</b>
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">fn</span> <span style="color: #0000ff;">sum_of_squares</span>(<span style="color: #a0522d;">x</span> : <span style="color: #228b22;">u32</span>, <span style="color: #a0522d;">y</span> : <span style="color: #228b22;">u32</span>) -&gt; <span style="color: #228b22;">u32</span> {
    <span style="color: #a020f0;">let</span> <span style="color: #a0522d;">x_squared</span> = x * x;
    <span style="color: #a020f0;">let</span> <span style="color: #a0522d;">y_squared</span> = y * y;
    x_squared + y_squared <span style="color: #b22222;">// </span><span style="color: #b22222;">NO SEMICOLON</span>
}
</pre>
</div>
</blockquote>
</div>
</div>
<div id="outline-container-orgf003f59" class="outline-3">
<h3 id="orgf003f59"><span class="section-number-3">3.5.</span> Statements and Expressions</h3>
<div class="outline-text-3" id="text-3-5">
<blockquote>
<p>
<b>Grammar:</b>
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">stmts</span>&gt;      <span style="color: #008b8b;">::=</span> &#1013;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">fun-decl</span>&gt; &lt;<span style="color: #483d8b;">stmts</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">stmt</span>&gt; &#65307;&lt;<span style="color: #483d8b;">stmts</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr</span>&gt; &#65307;&lt;<span style="color: #483d8b;">stmts</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">expr-no-sc</span>&gt; &lt;<span style="color: #483d8b;">stmts</span>&gt;
&lt;<span style="color: #0000ff;">stmt</span>&gt;       <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-decl</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">const-decl</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">assign</span>&gt;
&lt;<span style="color: #0000ff;">expr-no-sc</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">if-expr</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">while-expr</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">for-expr</span>&gt;
&lt;<span style="color: #0000ff;">expr</span>&gt;       <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">block</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">lit</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">uop-expr</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">bop-expr</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">call-expr</span>&gt;
               <span style="color: #ff0000; font-weight: bold;">|</span> ( &lt;<span style="color: #483d8b;">expr</span>&gt; )
&lt;<span style="color: #0000ff;">uop-expr</span>&gt;   <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">uop</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">bop-expr</span>&gt;   <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">bop</span>&gt; &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">uop</span>&gt;        <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; see docs ;</span>
&lt;<span style="color: #0000ff;">bop</span>&gt;        <span style="color: #008b8b;">::=</span> <span style="color: #b22222;">; see docs ;</span>
&lt;<span style="color: #0000ff;">call-expr</span>&gt;  <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">fn-ident</span>&gt;(&lt;<span style="color: #483d8b;">exprs</span>&gt;)<span style="color: #b22222;">;</span>
</pre>
</div>
</blockquote>

<p>
Statements perform actions and do not have a value.  Expressions have
values (and are evaluated).  The only statements we've seen so far are
declarations.  Any expression can be assigned to a variable (you
should check this, it works even for things like <code>while</code> expressions).
</p>
</div>
</div>
<div id="outline-container-org1249811" class="outline-3">
<h3 id="org1249811"><span class="section-number-3">3.6.</span> Control Flow</h3>
<div class="outline-text-3" id="text-3-6">
<blockquote>
<p>
<b>Grammar:</b>
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">if-expr</span>&gt;      <span style="color: #008b8b;">::=</span> if &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">block</span>&gt; &lt;<span style="color: #483d8b;">else-if-expr</span>&gt;
&lt;<span style="color: #0000ff;">else-if-expr</span>&gt; <span style="color: #008b8b;">::=</span> &#1013; <span style="color: #ff0000; font-weight: bold;">|</span> else &lt;<span style="color: #483d8b;">block</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> else if &lt;<span style="color: #483d8b;">block</span>&gt; &lt;<span style="color: #483d8b;">else-if-expr</span>&gt;
&lt;<span style="color: #0000ff;">while-expr</span>&gt;   <span style="color: #008b8b;">::=</span> while &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">block</span>&gt;
&lt;<span style="color: #0000ff;">for-expr</span>&gt;     <span style="color: #008b8b;">::=</span> for &lt;<span style="color: #483d8b;">var-ident</span>&gt; in &lt;<span style="color: #483d8b;">expr</span>&gt; &lt;<span style="color: #483d8b;">block</span>&gt;
&lt;<span style="color: #0000ff;">ret-expr</span>&gt;     <span style="color: #008b8b;">::=</span> return &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">expr</span>&gt;         <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">if-expr</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">while-expr</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">for-expr</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">ret-expr</span>&gt;
</pre>
</div>
</blockquote>

<p>
Control flow is also pretty standard. A couple things to keep in mind:
</p>
<ul class="org-ul">
<li>control flow is defined by <i>expressions</i>. This means they can be
used as the values of variables; this is particularly nice for
if-expressions</li>
<li>the then-case and the else-case blocks must be the same type</li>
</ul>

<blockquote>
<p>
<b>Example.</b>
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">fn</span> <span style="color: #0000ff;">is_prime</span>(<span style="color: #a0522d;">n</span>: <span style="color: #228b22;">i32</span>) -&gt; <span style="color: #228b22;">bool</span> {
    <span style="color: #a020f0;">for</span> <span style="color: #a0522d;">i</span> <span style="color: #a020f0;">in</span> 2..n {
        <span style="color: #a020f0;">if</span> n % i == 0 {
            <span style="color: #a020f0;">return</span> <span style="color: #a020f0;">false</span>
        }
    }
    <span style="color: #a020f0;">true</span>
}
</pre>
</div>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org0a94ba6" class="outline-2">
<h2 id="org0a94ba6"><span class="section-number-2">4.</span> Ownership</h2>
<div class="outline-text-2" id="text-4">
<p>
Ownership accounts for the first plateau in the learning curve of
Rust.  In rough terms, <i>values have owners</i>, e.g., values aren't
necessarily copied on reassignment.<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>
Ownership is motivated by the way that Rust (and many systems PLs)
manages memory, so we have to spend some a bit of time learning about
this.
</p>
</div>
<div id="outline-container-stack_and_heap" class="outline-3">
<h3 id="stack_and_heap"><span class="section-number-3">4.1.</span> Stack and Heap</h3>
<div class="outline-text-3" id="text-stack_and_heap">
<p>
Rust is a systems PL, which means that we need to care at least a
little bit about how memory is managed.  We won't be going all the way
to the hardware; we'll take a sufficiently detailed view to be able to
appreciate the interesting aspects of Rust's type/borrow system, and a
sufficiently abstract view as to not get caught up in implementation
details, e.g., of the memory allocator.
</p>

<p>
There are, in rough terms, three kinds of memory we need to care about
(though we'll primarily focus on the latter two):
</p>

<ol class="org-ol">
<li>static memory</li>
<li>the stack</li>
<li>the heap</li>
</ol>

<p>
Static memory consists of constants used throughout the execution of a
program; it's located in a fixed place which is accessible during
execution and the values therein never change.  For example, when we
define a variable whose value is a <i>string slice</i>:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">let</span> <span style="color: #a0522d;">x</span> : <span style="color: #000000; background-color: #ffffff;">&amp;</span><span style="color: #228b22;">str</span> = <span style="color: #8b2252;">"hello world"</span>
</pre>
</div>

<p>
The <code>"hello world"</code> part is stored in static memory and <code>x</code> is given a
reference to this location.  This is about all we'll say about static
memory.<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>
</p>

<p>
Next up, the <b>stack</b>. The stack consists of the values of parameters and
local variables relevant to a function call.<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup>
There are a lot of positive things to say about the stack:
</p>

<ul class="org-ul">
<li>Values put on the stack are very quick to access─they're "right
there", so to speak, when a function is called.</li>
<li>The stack is compactly organized; it's first-in first-out, there's
no wasted space, everything relevant to the function is there when
we need it, and thrown away when we're done with it.</li>
</ul>

<p>
This seems ideal.<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>  The problem: there are three major
restrictions on the kind of data that can be put on the stack:
</p>

<ol class="org-ol">
<li>The data must be fixed-size, known at compile time.</li>
<li>The data cannot change size throughout the execution of the
program.</li>
<li>The data on the stack relevant to a function does not persist after
control is returned to the caller.</li>
</ol>

<p>
It's worth noting before moving on that, although these are common
restrictions among systems PLs, they are ultimately design decisions;
this optimization allows the Rust compiler to know <i>exactly</i> how much
memory to allocate when a function is called.  There is nothing
inherent to a stack which makes it so we can't store data whose size
is unknown at compile time (variable-size data is a different
question, that would be much harder to deal with in a stack).
</p>

<p>
So, if we want to do "reasonable" programming, i.e., programming with
potentially persistent data of potentially variable size, we need to
put it somewhere else in memory.
</p>

<p>
The <b>heap</b> is where we store this variable-size persistent data.
Because the size is unknown at runtime, the program itself has to
<i>allocate</i> that memory, i.e., it has to ask a memory allocator for the
amount of memory that it wants.  And because the data may be
persistent, we have to tell the memory allocator when we're done with
it.  This also means that, when we work with data on the heap, we need
a level of indirection; if a function call needs access to data on the
heap we put a <i>reference</i> on the stack, which we can follow to get to
that data.
</p>

<p>
There are a lot of negative things to say about the
heap:
</p>

<ul class="org-ul">
<li>Access is slower; the processor has to potentially jump around;
there may (read: are likely to) be references to references to
references, and following these references takes time.</li>
<li>The heap is organized less compactly; if we tell the memory
allocator we no longer need some data on the heap, the memory
allocator can <i>free</i> it so that it can be used later, but this may
<i>fragment</i> the heap, leaving "holes" that add up to a large amount
of memory, but cannot be used to hold a contiguous piece of data.</li>
<li>The system of allocation/deallocation is <i>exactly</i> the source of
memory bugs:
<ul class="org-ul">
<li>A <i>dangling point</i> is what you get when you keep around a
reference to a location on the heap that no longer contains valid
data.</li>
<li>A <i>memory leak</i> is what you get when you allocate memory, but lose
the reference to it so that it can't be freed.</li>
<li>A <i>data race</i> is what you get when you have multiple processes
vying for the same data on the heap.</li>
</ul></li>
</ul>

<p>
It's a kind of Pandora's box; the reality is we need the heap, we need to
be able to work with variable-sized persistent data. And maybe part of
our goal will be to minimize heap allocation where possible in the
case that memory allocation/deallocation becomes a bottleneck, but we
can't do much without it.<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup>
</p>

<blockquote>
<p>
<b>The Picture.</b> You'll often see diagrams of this form to describe the
layout of memory.  The stack and heap grow in opposite directions.
And there may be "holes" on the heap due to freed memory.  It's a bit
of a caricature but is sufficient for our purposes.
</p>

<div class="org-src-container">
<pre class="src src-text">  (HIGH ADDRS)
&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
&#9474; FN1 PARAM     &#9474; STACK
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508; &#8595;&#8595;&#8595;&#8595;&#8595;
&#9474; FN1 LOCAL VAR &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; FN1 LOCAL VAR &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; FN2 PARAM     &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; FN2 PARAM     &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; FN2 LOCAL VAR &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; FN2 LOCAL VAR &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
        &#8942;
        &#8942;
        &#8942;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; HEAP DATA     &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; FREE          &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; FREE          &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474; HEAP DATA     &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508; &#8593;&#8593;&#8593;&#8593;
&#9474; HEAP DATA     &#9474; HEAP
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;&#9582;
&#9474; CONSTANTS     &#9474;&#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;&#9500;STATIC
&#9474; CONSTANTS     &#9474;&#9474;
&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;&#9583;
  (LOW ADDRS)
</pre>
</div>
</blockquote>

<p>
Okay, so we have the stack and the heap, and all systems PLs have to
deal with the tradeoffs presented by these two kinds of memory.  There
are, in broad strokes, four ways that have become common approaches
(in order roughly of decreasing user control):
</p>

<ol class="org-ol">
<li>Explicit allocation/deallocation (C)</li>
<li><b>Ownership (Rust)</b></li>
<li>Automatic Reference Counting (Swift, C++ via smart pointers)</li>
<li>Garbage Collection (Python, Java, OCaml, pretty much all high-level
PLs)</li>
</ol>
</div>

<div id="outline-container-orgafd2b65" class="outline-4">
<h4 id="orgafd2b65"><span class="section-number-4">4.1.1.</span> Explicit Allocation</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
In "traditional" systems PLs like C, the programmer is in charge of
when to allocate and deallocate heap memory.<sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup>  This is done using the methods <code>malloc</code> (for
allocating) and <code>free</code> (for deallocating).  Pretty simple, for every
<code>malloc</code>, we need exactly one <code>free</code> when were done with the memory we
allocated.  Except that, as we learn from Uncle Ben, with great power
comes great responsibility.  Having control over allocation is what
also gives us the ability to introduce memory bugs, and experience has
shown us that these kinds of bugs are prevalent and difficult to track
down.
</p>

<blockquote>
<p>
<b>Example.</b> A dangling pointer in C.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">void</span>) {
  <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">x</span> = (<span style="color: #228b22;">int</span>*)malloc(<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>));
  *x = 2;
  free(x);
  printf(<span style="color: #8b2252;">"%d\n"</span>, *x);
  <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>
</blockquote>

<blockquote>
<p>
<b>Example.</b> A memory leak in C.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">leak</span>(<span style="color: #228b22;">void</span>) {
  <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">x</span> = (<span style="color: #228b22;">int</span>*)malloc(<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>));
  *x = 2;
  printf(<span style="color: #8b2252;">"%d\n"</span>, *x);
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">void</span>) {
  leak();
  <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>
</blockquote>
</div>
</div>

<div id="outline-container-orge25fad9" class="outline-4">
<h4 id="orge25fad9"><span class="section-number-4">4.1.2.</span> Garbage Collection</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
On the other side of the user-control spectrum is garbage collection,
which is an automatic way of allocating and deallocating memory.  It's
another idea which is simple in concept and complicated in detail:
periodically during the execution of the program we:
</p>
<ul class="org-ul">
<li>mark all the data on the heap that still has a reference in the
stack;</li>
<li>deallocate everything that on the heap which isn't marked.</li>
</ul>

<p>
The process that does this is called the <i>garbage collector</i> (GC).  No
more memory bugs, no more thinking about memory at all, <i>data is
data.</i> The drawback: with less responsibility comes less power.  We
give up compute to periodically clean up the heap.  And in most cases
this is fine, if we don't need performance then we don't need
performance.  But if we <i>do</i> need performance, there isn't much we can
do with a GC except maybe choose a better GC (some algorithms are
better than others, and performance can depend on the application
domain).
</p>
</div>
</div>

<div id="outline-container-org4568798" class="outline-4">
<h4 id="org4568798"><span class="section-number-4">4.1.3.</span> Automatic Reference Counting</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Before going into borrowing, I thought I'd point out one more
alternative to memory management, automatic reference counting,
notably used by Swift.  The idea:
</p>

<ul class="org-ul">
<li>keep track of the number of references to a piece of data on the
heap;</li>
<li>deallocate when that number is 0.</li>
</ul>

<blockquote>
<p>
<b>Example.</b> The Swift documentation has a nice example of this.  This
 program only prints <code>allocating</code> and <code>deallocating</code> once, even though
 a reference goes out of scope several times.
</p>

<div class="org-src-container">
<pre class="src src-swift"><span style="color: #a020f0;">class</span> <span style="color: #0000ff;">Stuff</span> {
    <span style="color: #a020f0;">init</span>() {
        <span style="color: #483d8b;">print</span>(<span style="color: #8b2252;">"allocating"</span>)
    }
    <span style="color: #a020f0;">deinit</span> {
        <span style="color: #483d8b;">print</span>(<span style="color: #8b2252;">"deallocating"</span>)
    }
}

<span style="color: #a020f0;">var</span> r1 : Stuff? = <span style="color: #0000ff;">Stuff</span>()
<span style="color: #a020f0;">var</span> r2 : Stuff? = r1
<span style="color: #a020f0;">var</span> r3 : Stuff? = r2

r1 = <span style="color: #008b8b;">nil</span>
r2 = <span style="color: #008b8b;">nil</span>
r3 = <span style="color: #008b8b;">nil</span>
</pre>
</div>

<pre class="example">
allocating
deallocating
</pre>
</blockquote>



<p>
This is a nice idea, it has its benefits and drawbacks, some of which
we'll discuss more later.  Rust also supports this style of memory
management, so the community must see something in it.
</p>
</div>
</div>

<div id="outline-container-org285aa96" class="outline-4">
<h4 id="org285aa96"><span class="section-number-4">4.1.4.</span> Ownership</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
Finally, the protagonist of our story, Rust's ownership.  This
approach lies somewhere between explicit allocation and reference
counting; you never have to allocate memory explicitly in Rust, but
there's no unspoken runtime computations (like reference count
updating) happening in the background.
</p>

<p>
According to the RPL, the ownership rules of Rust are:
</p>

<ul class="org-ul">
<li>Every value has a single owner.</li>
<li>When the owner goes out of scope, any memory associated with the
value is freed.</li>
</ul>

<p>
I think the best way to understand these rules is to focus on the
second one: <i>when a variable goes out of scope, we free its associated
memory.</i> This is a stupid-simple policy, and it certainly solves the
problem of memory leaks; every variable <i>must</i> go out of scope at some
point, so there's at least one deallocation for every allocation.
</p>

<p>
But this is an awful policy when it comes to dangling pointers.  How
do we know that there isn't some other reference to the same data when
we go to free it?  Not to mention it's problematic with respect to
freeing memory that's not allocated (i.e., more than one deallocation
for one allocation).
</p>

<p>
This is where the first rule comes in: when a variable goes out of
scope, they must <i>own</i> the data. No one else can refer to it.  In
other words, ownership (the idea that every value has an owner) allows
us to adopt a stupid-simple policy on freeing data (free when your
owner goes out of scope).  Another way to think about it: it's like
automatic reference counting, except you're not allowed to have a
reference count greater than 1.
</p>


<blockquote>
<p>
<b>Example.</b> This policy means there are things we just <i>cannot</i> do,
e.g., we can't have two references to the same data on the heap.  If
one goes out of scope, it will free its associated data, leaving the
second one referring to data that is no longer valid.
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">fn</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">let</span> <span style="color: #a0522d;">x</span> = <span style="color: #228b22;">String</span>::from(<span style="color: #8b2252;">"hello world"</span>);
    <span style="color: #a020f0;">let</span> <span style="color: #a0522d;">y</span> = x;
    <span style="color: #483d8b;">println!</span>(<span style="color: #8b2252;">"</span><span style="color: #8b2252; font-style: italic;">{x}</span><span style="color: #8b2252;">"</span>);
    <span style="color: #483d8b;">println!</span>(<span style="color: #8b2252;">"</span><span style="color: #8b2252; font-style: italic;">{y}</span><span style="color: #8b2252;">"</span>);
}
</pre>
</div>
<pre class="example">
error[E0382]: borrow of moved value: `x`
  --&gt; src/main.rs:49:15
   |
47 |     let x = String::from("hello world");
   |         - move occurs because `x` has type `String`, which does not implement the `Copy` trait
48 |     let y = x;
   |             - value moved here
49 |     println!("{x}");
   |               ^^^ value borrowed here after move
   |
</pre>

<p>
When we try this, we get a <i>type error</i>. And this is important to
emphasize, it's not a runtime error.  It's also worth noting there
nothing inherently wrong with this code from a computational
perspective.  Consider the equivalent C code:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">void</span>) {
  <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">x</span> = <span style="color: #8b2252;">"hello world"</span>;
  <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">y</span> = x;
  printf(<span style="color: #8b2252;">"%s\n"</span>, x);
  printf(<span style="color: #8b2252;">"%s\n"</span>, y);
  <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
hello world
hello world
</pre>

<p>
But it is the philosophy of Rust that we should program
conservatively, disallowing some things, and thank ourselves in the
long run, instead of coding fast-and-loose, doing whatever we want,
and potentially paying for it later.<sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup>
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgc5f42dc" class="outline-3">
<h3 id="orgc5f42dc"><span class="section-number-3">4.2.</span> References and Borrowing</h3>
<div class="outline-text-3" id="text-4-2">
<p>
I'm gonna put to <a href="https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html">RPL 4.2</a> here.
</p>
</div>
</div>
<div id="outline-container-orgc9f2fb4" class="outline-3">
<h3 id="orgc9f2fb4"><span class="section-number-3">4.3.</span> Slice Types</h3>
</div>
</div>
<div id="outline-container-org695b3eb" class="outline-2">
<h2 id="org695b3eb"><span class="section-number-2">5.</span> Structures</h2>
<div class="outline-text-2" id="text-5">
<p>
Structure definition syntax:
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">stmts</span>&gt;      <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">stmt-no-sc</span>&gt; &lt;<span style="color: #483d8b;">stmts</span>&gt;
&lt;<span style="color: #0000ff;">stmt</span>&gt;       <span style="color: #008b8b;">::=</span> struct &lt;<span style="color: #483d8b;">struct-ident</span>&gt;
&lt;<span style="color: #0000ff;">stmt-no-sc</span>&gt; <span style="color: #008b8b;">::=</span> struct &lt;<span style="color: #483d8b;">struct-ident</span>&gt; { &lt;<span style="color: #483d8b;">ft-pairs</span>&gt; }
&lt;<span style="color: #0000ff;">ft-pairs</span>&gt;   <span style="color: #008b8b;">::=</span> &#1013; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">ft-pair</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">ft-pair</span>&gt; , &lt;<span style="color: #483d8b;">ft-pairs</span>&gt;
&lt;<span style="color: #0000ff;">ft-pair</span>&gt;    <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-ident</span>&gt; : &lt;<span style="color: #483d8b;">ty</span>&gt;
</pre>
</div>
<p>
Structure identifiers must be capitalized.
</p>

<p>
Example:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Player</span> {
    <span style="color: #a0522d;">name</span>: <span style="color: #228b22;">String</span>,
    <span style="color: #a0522d;">score</span>: <span style="color: #228b22;">i32</span>,
}
</pre>
</div>

<p>
Stucture instantiation syntax:
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt;     <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">struct-ident</span>&gt;
             <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">struct-ident</span>&gt; { &lt;<span style="color: #483d8b;">fv-pairs</span>&gt; }
             <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">struct-ident</span>&gt; ( &lt;<span style="color: #483d8b;">tys</span>&gt; )
&lt;<span style="color: #0000ff;">fv-pairs</span>&gt; <span style="color: #008b8b;">::=</span> &#1013; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">fv-pair</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">fv-pair</span>&gt; , &lt;<span style="color: #483d8b;">fv-pairs</span>&gt;
&lt;<span style="color: #0000ff;">fv-pairs</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-ident</span>&gt; : &lt;<span style="color: #483d8b;">expr</span>&gt; <span style="color: #ff0000; font-weight: bold;">|</span> &lt;<span style="color: #483d8b;">var-ident</span>&gt;
</pre>
</div>
<p>
Note the use of <i>tuple structures</i> and <i>field init shorthand</i> syntax.
</p>

<p>
Example:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #a020f0;">let</span> <span style="color: #a0522d;">p</span> = <span style="color: #228b22;">Player</span> {
    <span style="color: #a0522d;">name</span>: <span style="color: #228b22;">String</span>::from(<span style="color: #8b2252;">"Ash"</span>),
    <span style="color: #a0522d;">score</span>: 0,
}
</pre>
</div>

<p>
Field access/update syntax (dot-notation):
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">assign</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">var-ident</span>&gt;.&lt;<span style="color: #483d8b;">var-ident</span>&gt; = &lt;<span style="color: #483d8b;">expr</span>&gt;
&lt;<span style="color: #0000ff;">expr</span>&gt;   <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">expr</span>&gt;.&lt;<span style="color: #483d8b;">var-ident</span>&gt;
</pre>
</div>

<p>
Structure update syntax:
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">expr</span>&gt; <span style="color: #008b8b;">::=</span> &lt;<span style="color: #483d8b;">struct-ident</span>&gt; { &lt;<span style="color: #483d8b;">fv-pairs</span>&gt;..&lt;<span style="color: #483d8b;">expr</span>&gt; }
</pre>
</div>
</div>

<div id="outline-container-orgaf9bb52" class="outline-3">
<h3 id="orgaf9bb52"><span class="section-number-3">5.1.</span> Structures and Ownership</h3>
<div class="outline-text-3" id="text-5-1">
<p>
It is common for structures to own their data.  It's possible to store
references, but this requires that we discuss lifetimes (to come, I
promise).
</p>

<p>
Values are moved <i>per field</i> so it is possible to move only a subset
of the values of a structure.  This should probably only be used for
self-updates.
</p>

<p>
<i>Question.</i> Why would we want to use <code>&amp;str</code> over <code>String</code> in a structure?
</p>

<p>
<b>Note.</b> References are short term. They should not usually be used to
 structure data.
</p>

<p>
<i>Question.</i> Can we build cyclic structures with references?
</p>
</div>
</div>

<div id="outline-container-org18fa05d" class="outline-3">
<h3 id="org18fa05d"><span class="section-number-3">5.2.</span> Derived Traits</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Derived trait
</p>
</div>
</div>

<div id="outline-container-org938c99b" class="outline-3">
<h3 id="org938c99b"><span class="section-number-3">5.3.</span> Methods</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Method syntax:
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">stmt-no-sc</span>&gt; <span style="color: #008b8b;">::=</span> impl &lt;<span style="color: #483d8b;">struct-ident</span>&gt; &lt;<span style="color: #483d8b;">block</span>&gt;
</pre>
</div>

<p>
We can have multiple implementation blocks
</p>

<p>
**Automatic reference/dereference
</p>
</div>
</div>

<div id="outline-container-orgb1869a4" class="outline-3">
<h3 id="orgb1869a4"><span class="section-number-3">5.4.</span> Associated Functions</h3>
<div class="outline-text-3" id="text-5-4">
<p>
We use the <code>Self</code> keyword:
</p>
<div class="org-src-container">
<pre class="src src-bnf">&lt;<span style="color: #0000ff;">ty</span>&gt;   <span style="color: #008b8b;">::=</span> Self
&lt;<span style="color: #0000ff;">expr</span>&gt; <span style="color: #008b8b;">::=</span> Self <span style="color: #ff0000; font-weight: bold;">|</span> Self { &lt;<span style="color: #483d8b;">tv-pairs</span>&gt; }
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org9187b38" class="outline-2">
<h2 id="org9187b38"><span class="section-number-2">6.</span> Proof Theory Primer</h2>
<div class="outline-text-2" id="text-6">
<p>
Proof theory is a subfield of mathematical logic which takes <i>proof</i>
as an object of formal study.  In a course on proof theory, we might
spend some time studying the various ways that proof can be
mathematically formalized (e.g., Fitch-style proofs, Hilbert-style
proofs, natural-deduction).  We'll focus on <i>formal systems</i> and
<i>sequent calculi</i>.
</p>

<p>
A <b>formal system</b> \(\mathcal F\) is given in terms of a class \(\mathcal
J\) of abstract entities called <b>judgments</b>, and consists of <b>inference
rules</b> over judgments in \(\mathcal J\), which are of the form
</p>

\begin{prooftree}
\AxiomC{$J_1$}
\AxiomC{$J_2$}
\AxiomC{$\dots$}
\AxiomC{$J_k$}
\QuaternaryInfC{$J_{k + 1}$}
\end{prooftree}

<p>
where \(k \geq 0\) and \(J_1, \dots, J_k\) are judgments from \(\mathcal
J\).  We read an inference rule as "If the judgments \(J_1, \dots, J_k\)
hold, then \(J_{k + 1}\) follows".  The judgments above the vertical line
are called <b>premises</b> and the judgment below is called the
<b>conclusion</b>.
</p>

<p>
A <b>derivation</b> \(\mathcal D\) in a formal system \(\mathcal F\) over the
judgments \(\mathcal J\) is a tree with the following properties:
</p>

<ul class="org-ul">
<li>the nodes of \(\mathcal D\) are judgments from \(\mathcal J\)</li>
<li><p>
A node \(J\) has the children \(J_1, \dots, J_k\) if and only if
</p>

\begin{prooftree}
\AxiomC{$J_1$}
\AxiomC{$J_2$}
\AxiomC{$\dots$}
\AxiomC{$J_k$}
\QuaternaryInfC{$J$}
\end{prooftree}

<p>
is an inference rule of \(\mathcal F\).
</p></li>
</ul>

<blockquote>
<p>
<b>Example:</b> We can consider a formal system over the judgments
\(\Sigma^*\) (where \(\Sigma\) is a fixed alphabet) with the inference
rules
</p>

<p>
\[
\frac{\qquad}{\sigma}
\qquad
\frac{S_1 \qquad S_2}{S_1 \circ S_2}
\]
</p>

<p>
where \(\sigma \in \Sigma\) and '\(\circ\)' is string concatenation.  We
could then write the derivation in the system over judgments from
\(\{0, 1\}^*\):
</p>

\begin{prooftree}
\AxiomC{$\qquad$}
\UnaryInfC{0}
\AxiomC{$\qquad$}
\UnaryInfC{1}
\BinaryInfC{01}
\AxiomC{$\qquad$}
\UnaryInfC{1}
\AxiomC{$\qquad$}
\UnaryInfC{0}
\BinaryInfC{10}
\BinaryInfC{0110}
\end{prooftree}

<p>
Technically speaking, the above rules actually define <i>classes</i> of
rules.  It looks as though this formal system has two rules, but the
presentation of a rule may encompass many rules simultaneously.
</p>
</blockquote>

<p>
Formal systems should feel familiar if you've CS320; they generalize
of <i>type systems</i> and <i>semantics</i> of PLs.
</p>

<p>
We could study formal systems proper (which are essentially
freely-generated algebraic structures) but we'll get more milage if we
fix ourselves to a class of formal systems with familiar structure.
In particular, we will want to use what are called <i>sequence calculi</i>.
</p>

<blockquote>
<p>
<b>Aside:</b> What exactly is a proof? Before we can answer this, we need to
say what kind of things we want to prove.  If we're interested in
mathematics, we might say that we prove theorems in a formal
mathematical language.  Even this is a bit ambiguous because not all
people agree on what mathematical language to use.
</p>

<p>
It is the business of philosophy to discuss the merits of different
formal languages and formal systems for doing mathematics (and, more
generally, analytic reasoning).  I much as I would love to discuss
this, it's not the goal here.  We will fix our formal systems and go
from there.
</p>
</blockquote>


<p>
Fix a language \(\mathcal L\) of which consists of statements.  A
<b>sequent</b> is a judgment of the form
</p>

<p>
\[
\phi_1, \dots, \phi_k \vdash \psi_1 \dots, \psi_l
\]
</p>

<p>
where \(k \geq 0\) and \(l \geq 1\) and \(\phi_1, \dots, \phi_k, \psi_1,
\dots, \psi_l\) are statements in \(\mathcal L\).  We read a sequent as
saying that "if \(\phi_1, \dots, \phi_k\) are hold, then one of \(\psi_1,
\dots, \psi_k\) hold".
</p>

<p>
For technically (but ultimately very interesting) reasons beyond the
scope of this note, we'll be interested exclusively in sequents of
the form:
</p>

<p>
\[
\phi_1, \dots, \phi_k \vdash \psi
\]
</p>

<p>
where there is a single formula to the right of the the '\(\vdash\)'.
</p>

<blockquote>
<p>
<b>Remark:</b> A sequent does not mean anything on it's own; it simply
organizes statements in a language in a way that "looks like" a common
form of reasoning: <i>such and such fact follows from such and such
assumptions.</i> We give sequents their meaning by building formal system
with sequents as judgments whose inference rules captures the nature
of this form of reasoning.
</p>
</blockquote>
</div>

<div id="outline-container-orgac6f538" class="outline-3">
<h3 id="orgac6f538"><span class="section-number-3">6.1.</span> Propositional Logic</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Propositional logic is the logic of Boolean connectives like "and" and
"or". It is the interest of propositional logic to determine how
logical connectives interact with our ability to derive new facts from
old ones.  For example, if both \(A\) and \(B\) follow from a collection
of assumptions \(\Gamma\), then it stands to reason that the compound
statement "\(A\) and \(B\)" follows as well. We will consider a formal
system (which we will call a <i>proof system</i> from now on) which
captures these sorts of rules.
</p>

<p>
First, we fix our language. A <b>propositional formula</b> is a syntactic
object defined over a set of propositional variables \(\mathcal P\).  We
should think of a propositional variable as a stand-in for an <i>atomic</i>
statement, like "it is raining" or "the house is on fire". The set of
propositional formulas is defined inductively as follows:
</p>

<ul class="org-ul">
<li>Every propositional variable is a propositional formula.</li>
<li>\(\bot\) is a propositional formula.</li>
<li>If \(\phi\) and \(\psi\) are propositional formulas then so is \((\phi
  \land \psi)\) and \((\phi \lor \psi)\) and \((\phi \to \psi)\).</li>
</ul>

<p>
We pronounce \(\land\) as "and", \(\lor\) as "or", \(\to\) as "implies", and
\(\bot\) as "false".  We'll take the usual precautions in eliding
parentheses.
</p>

<blockquote>
<p>
<b>Remark:</b> If you've taken an intro logic course, you might think "what
a strange set of connectives". Where's negation? Any why make
implication explicit instead of defining it in terms of other
connectives? In due time&#x2026;
</p>
</blockquote>

<blockquote>
<p>
<b>Example:</b> \((P \land (Q \lor R)) \to R \to \bot\) is a propositional formula with
propositional variables \(P\), \(Q\) and \(R\).
</p>
</blockquote>

<p>
This is our language. Again, it's meaningless, it's just syntax. We
give it meaning by defining how we can derive new formula from old
ones. Let's consider a system.
</p>
</div>

<div id="outline-container-org43c900a" class="outline-4">
<h4 id="org43c900a"><span class="section-number-4">6.1.1.</span> Assumptions</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
Our first inference rule says that all assumptions hold
(shocker). This is often called the "start" rule since it will always
be the leaves of our derivations.
</p>

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Delta, \phi, \Gamma \vdash \phi$}
\end{prooftree}

<p>
where \(\Delta\) and \(\Gamma\) are sequences of formulas.
</p>
</div>
</div>

<div id="outline-container-org3f1c698" class="outline-4">
<h4 id="org3f1c698"><span class="section-number-4">6.1.2.</span> Falsity</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
This rule is often called the <i>principle of explosion</i>. If we can
prove false, we might as well throw our hands in the air and prove
anything
</p>

<p>
\[
\frac{\Gamma \vdash \bot}{\Gamma \vdash \phi}
\]
</p>
</div>
</div>

<div id="outline-container-org43053a0" class="outline-4">
<h4 id="org43053a0"><span class="section-number-4">6.1.3.</span> Conjunction</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Our next set of rules describe how we reason about conjunction.  If
both \(\phi\) and \(\psi\) follow from a collection of assumptions, then
so does their conjunction.  And if a conjunction follows from a
collection of assumptions, then so do their individual conjuncts.
</p>

<p>
\[
\frac
{\Gamma \vdash \phi \qquad \Gamma \vdash \psi}
{\Gamma \vdash \phi \land \psi}
\qquad
\frac
{\Gamma \vdash \phi \land \psi}
{\Gamma \vdash \phi}
\qquad
\frac
{\Gamma \vdash \phi \land \psi}
{\Gamma \vdash \psi}
\]
</p>
</div>
</div>

<div id="outline-container-orgce0ed0f" class="outline-4">
<h4 id="orgce0ed0f"><span class="section-number-4">6.1.4.</span> Disjunction</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
We get a similar set of disjunction, though one is a bit more
involved. The first two are simple: if a formula holds then we can
disjunct it with another formula. The last says: <i>if something follows
from both disjuncts, and the disjunction holds, then the
"something" holds.</i>
</p>

<p>
\[
\frac
{\Gamma \vdash \phi}
{\Gamma \vdash \phi \lor \psi}
\qquad
\frac
{\Gamma \vdash \psi}
{\Gamma \vdash \phi \lor \psi}
\qquad
\frac
{\Gamma \vdash \phi \lor \psi \qquad \Gamma, \phi \vdash \xi \qquad \Gamma, \psi \vdash \xi}
{\Gamma \vdash \xi}
\]
</p>
</div>
</div>

<div id="outline-container-org7599fa9" class="outline-4">
<h4 id="org7599fa9"><span class="section-number-4">6.1.5.</span> Implication</h4>
<div class="outline-text-4" id="text-6-1-5">
<p>
The first rule tells us that if \(\psi\) follows from a collection of
assumptions including \(\psi\), then \(\phi \to \psi\) holds <i>without</i>
\(\phi\) as an assumption. The second rule should be familiar, it's just
<i>modus ponens</i>.
</p>

<p>
\[
\frac
{\Gamma, \phi \vdash \psi}
{\Gamma \vdash \phi \to \psi}
\qquad
\frac
{\Gamma \vdash \phi \to \psi \qquad \Gamma \vdash \phi}
{\Gamma \vdash \psi}
\]
</p>

<p>
And we'll leave it there, now we have a proof system for propositional
logic and we can talk about formulas which are <i>provable</i> in this
proof system.
</p>

<blockquote>
<p>
<b>Remark:</b> If this we're a logic course, we would be at a starting
point for a number of very interesting topics, e.g., soundness and
completeness. In particular, how do we know that we've chosen "good"
rules? Short answer: these rules should have desirable metatheoretic
properties.  We won't get into this. Instead, we'll take for granted
that this is a reasonable set of inference rules.
</p>
</blockquote>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">My nature does not allow me to introduce
anything without a wannabe-hybrid-Salinger-Wallace-esqe preamble.  I
wish it didn't have to be this way but at some point, we can't break
from our aesthetic inclinations.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">An uncommon pairing, most popular languages are beige
wallpaper boring.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">I don't
even like Rust that much, to be honest.  It's probably most
fascinating to me from a social theoretical perspective than from a PL
design perspective.</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">I had a
conversation with some folks about possible alternative idioms.  PETA
recommends "feed two birds with one scone". Not punchy enough in my
opinion.  My dad came up with two pretty good ones: "strike out to
batters with one pitch" (nonsensical in a pleasant way) and "destroy
two planets with one deathstar" (to better align with nerd culture).</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">In Rust we're able to
<i>specify</i> whether something is copied on reassignments (using a
mechanism called <i>traits</i>, similar to interfaces or type classes).</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">We include this brief note about it basically to answer the
question: <i>If we have a parameter to a function which is a string
slice, where is that slice actually stored?</i> It can't be be on the
stack because the size of data on the stack has to be known at compile
time.</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">The stack is also
occasionally called the <i>call stack</i>, but prefer to be a bit cagey on
this, as there are certainly examples of programming languages which
draw a distinction between the call stack and the stack used during
the execution of a program, e.g., some implementations of Forth.</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">And this is, in essence, the motivation behind
stack-oriented PLs like Forth: fine-grained control of the stack means
more efficient program.</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">And we should generally be wary of
pre-mature optimization</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Hard-core C
programmers like to point out that there is no notion of stack and
heap in the C specification.  I can't claim to have a strong argument
against this─I'm not a systems programmer─except that everyone already
thinks of allocation as heap allocation in C, and this underlying some
C compilers.</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">As we will see, this
philosophy also pays off when we want to parallelize our code.</p></div></div>


</div>
</div></div>
</body>
</html>
